#ifndef __MIDDLEWARE_INTERFACES_HPP
#define __MIDDLEWARE_INTERFACES_HPP

#include <array>
#include "middleware_defines.hpp"
#include "middleware_types.hpp"

namespace MW_GPIO {
    /**
     * @brief Interface describing GPIO functionality required from middleware.
     * This interface requires methods to write, read, and toggle GPIO pins.
     * GPIO middleware is primarily used for turning on/off LEDs.
     * @warning While there are many GPIO pins available, only some of them are
     * properly configured for GPIO functionality. Ensure that the pins you
     * are using are configured correctly. Inspect CubeMX or @see gpio.c.
     */
    class IGPIO {
       public:
        /**
        * @brief Set the state of a GPIO pin.
        * @param[in] port The GPIO port of the pin to set.
        * @param[in] pin The pin number of the pin to set.
        * @param[in] state The state to set the pin to (HIGH, or LOW).
        */
        virtual void write_pin(Port port, Pin pin, State state) = 0;

        /**
         * @brief Read the state of a GPIO pin.
         * @param[in] port The GPIO port of the pin to read.
         * @param[in] pin The pin number of the pin to read.
         * @return The current state of the pin (HIGH, or LOW).
         */
        virtual State read_pin(Port port, Pin pin) = 0;

        /**
         * @brief Toggle the state of a GPIO pin.
         * @param[in] port The GPIO port of the pin to toggle.
         * @param[in] pin The pin number of the pin to toggle.
         */
        virtual void toggle_pin(Port port, Pin pin) = 0;
    };
}  // namespace MW_GPIO

namespace MW_TIM {
    /**
     * @brief Interface describing PWM functionality required from middleware.
     * This interface requires methods to start, stop, and configure PWM signals.
     * PWM middleware is primarily used for controlling servos for ammo-lids and 
     * fly-swatters.
     * @warning While there are many Timers and channels available, only some of them are
     * configured for PWM generation. Ensure that the pins you are using are configured 
     * correctly. Inspect CubeMX or @see tim.c.
     */
    class IPWM {
       public:
        /**
         * @brief Start PWM generation for a specific timer and channel.
         * @param[in] timer Timer to start.
         * @param[in] channel Channel of timer to start.
        */
        virtual void start(Timer timer, Channel channel) = 0;

        /**
         * @brief Stop PWM generation for a specific timer and channel.
         * @param[in] timer Timer to stop.
         * @param[in] channel Channel of timer to stop.
         */
        virtual void stop(Timer timer, Channel channel) = 0;

        /**
         * @brief Set the compare value of a PWM signal generated by a timer.
         * Changing the compare value directly affects the duty cycle of the PWM
         * signal generated. To calculate the exact compare value for a desired
         * duty cycle use this formula:
         * \f$\frac{compare_value}{TIMx->ARR + 1} * 100%\f$
         * @param[in] timer Timer to set.
         * @param[in] channel Channel of timer to set.
         * @param[in] compare_value The duty cycle of the PWM signal (0-100%).
         */
        virtual void set_duty_cycle(Timer timer, Channel channel,
                                    uint32_t compare) = 0;
    };
}  // namespace MW_TIM

namespace MW_CAN {
    /**
     * @brief Interface describing CANBUS functionality required from middleware.
     * This interface requires methods to send and receive CAN messages, start and stop the CAN bus,
     * activate notifications, and configure filters.
     * @note This interface assumes that hardware supports atleast CAN 2.0B standard and there are
     * two CAN buses available (CAN 1 and CAN 2). Finer configuration of CAN buses (e.g. baud rate, 
     * auto-retransmission) is not required.
     */
    class ICAN {
       public:
        /**
         * @brief Send data over the CAN bus.
         * Must support sending variable-length data frames with a maximum length of 8 bytes.
         * @pre 0 < length <= 8
         * @param[in] bus The CAN bus to send data on.
         * @param[in] id The ID of the message to send.
         * @param[in] data The data to send.
         * @param[in] length The length of the data.
         */
        virtual void send_data(BUS bus, uint32_t id,
                               const std::array<uint8_t, 8>& data,
                               uint32_t length) = 0;

        /**
         * @brief Receive data from the CAN bus.
         * Must support receiving variable-length data frames with a maximum length of 8 bytes.
         * @param[in] bus The CAN bus to receive data from.
         * @param[in] fifo The FIFO to read from.
         * @param[out] id The ID of the received message.
         * @param[out] length The length of the received data.
         * @param[out] data The buffer to store the received data.
         */
        virtual bool receive_data(BUS bus, FIFO fifo, uint32_t& id,
                                  uint32_t& length,
                                  std::array<uint8_t, 8>& data) = 0;

        /**
         * @brief Start the CAN bus communication.
         * @param[in] bus The CAN bus to start.
         */
        virtual void start(BUS bus) = 0;

        /**
         * @brief Stop the CAN bus communication.
         * @param[in] bus The CAN bus to stop.
         */
        virtual void stop(BUS bus) = 0;

        /**
         * @brief Activate a CAN notification.
         * @param[in] bus The CAN bus to activate the notification on.
         * @param[in] notification The notification type to activate.
         */
        virtual void activate_notification(BUS bus,
                                           Notification notification) = 0;

        /**
         * @brief Configure a CAN filter.
         * @param[in] bus The CAN bus to configure.
         * @param[in] filter_configuration The filter configuration to apply.
         */
        virtual void configure_filter(BUS bus, Filter filter_configuration) = 0;
    };
}  // namespace MW_CAN

namespace MW_UART {
    /**
     * @brief Interface describing UART functionality required from middleware.
     * This interface requires methods to send and receive UART data, start and stop the UART 
     * communication. UART middleware is primarily used for debugging and communication 
     * with external devices like Mini-PC.
     */
    class IUART {
       public:
        /**
         * @brief Send data over UART.
         * @param[in] uart The UART peripheral to send data on.
         * @param[in] data The data to send.
         * @param[in] length The length of the data.
         * @param[in] timeout The timeout for the transmission.
         */
        virtual void send_data(
            Peripheral uart,
            const std::array<uint8_t, MAX_UART_BUFFER_SIZE>& data,
            uint32_t length, uint32_t timeout) = 0;

        /**
         * @brief Start reception of data from UART.
         * @note This method cannot be blocking.
         * @param[in] uart The UART peripheral to receive data from.
         * @param[out] data The buffer to store the received data.
         * @param[out] length The length of the received data.
         * @return true if data was received successfully, false otherwise.
         * @pre 0 < length <= MAX_UART_BUFFER_SIZE
         */
        virtual bool receive_data(
            Peripheral uart, std::array<uint8_t, MAX_UART_BUFFER_SIZE>& data,
            uint32_t& length) = 0;

        /**
         * @brief Abort receiving data on the UART peripheral.
         * @param[in] uart The UART peripheral to abort receiving data on.
         */
        virtual void abort_receive(Peripheral uart) = 0;

        /**
         * @brief Abort transmitting data on the UART peripheral.
         * @param[in] uart The UART peripheral to abort.
         */
        virtual void abort_transmit(Peripheral uart) = 0;
    };
}  // namespace MW_UART

#endif