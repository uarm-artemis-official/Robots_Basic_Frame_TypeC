/*
 * ssd1306.c
 *
 *  Created on: Apr 19, 2025
 *      Author: johnm
 *
 * 	This and related files contains driver code displaying simple scrollable text
 * 	messages onto 128x64 OLED screens controlled by SSD1306 drivers (e.g. DFR0650).
 */

#include "ssd1306_driver.h"

// 5x7 font used for drawing characters onto OLED display.
static const uint8_t font5x7[][5] = {
    // ASCII 0x20 (space) to 0x7E (~)
    {0x00, 0x00, 0x00, 0x00, 0x00},  // 0x20 ' '
    {0x00, 0x00, 0x5F, 0x00, 0x00},  // 0x21 '!'
    {0x00, 0x07, 0x00, 0x07, 0x00},  // 0x22 '"'
    {0x14, 0x7F, 0x14, 0x7F, 0x14},  // 0x23 '#'
    {0x24, 0x2A, 0x7F, 0x2A, 0x12},  // 0x24 '$'
    {0x23, 0x13, 0x08, 0x64, 0x62},  // 0x25 '%'
    {0x36, 0x49, 0x55, 0x22, 0x50},  // 0x26 '&'
    {0x00, 0x05, 0x03, 0x00, 0x00},  // 0x27 '''
    {0x00, 0x1C, 0x22, 0x41, 0x00},  // 0x28 '('
    {0x00, 0x41, 0x22, 0x1C, 0x00},  // 0x29 ')'
    {0x14, 0x08, 0x3E, 0x08, 0x14},  // 0x2A '*'
    {0x08, 0x08, 0x3E, 0x08, 0x08},  // 0x2B '+'
    {0x00, 0x50, 0x30, 0x00, 0x00},  // 0x2C ','
    {0x08, 0x08, 0x08, 0x08, 0x08},  // 0x2D '-'
    {0x00, 0x60, 0x60, 0x00, 0x00},  // 0x2E '.'
    {0x20, 0x10, 0x08, 0x04, 0x02},  // 0x2F '/'
    {0x3E, 0x51, 0x49, 0x45, 0x3E},  // 0x30 '0'
    {0x00, 0x42, 0x7F, 0x40, 0x00},  // 0x31 '1'
    {0x42, 0x61, 0x51, 0x49, 0x46},  // 0x32 '2'
    {0x21, 0x41, 0x45, 0x4B, 0x31},  // 0x33 '3'
    {0x18, 0x14, 0x12, 0x7F, 0x10},  // 0x34 '4'
    {0x27, 0x45, 0x45, 0x45, 0x39},  // 0x35 '5'
    {0x3C, 0x4A, 0x49, 0x49, 0x30},  // 0x36 '6'
    {0x01, 0x71, 0x09, 0x05, 0x03},  // 0x37 '7'
    {0x36, 0x49, 0x49, 0x49, 0x36},  // 0x38 '8'
    {0x06, 0x49, 0x49, 0x29, 0x1E},  // 0x39 '9'
    {0x00, 0x36, 0x36, 0x00, 0x00},  // 0x3A ':'
    {0x00, 0x56, 0x36, 0x00, 0x00},  // 0x3B ';'
    {0x08, 0x14, 0x22, 0x41, 0x00},  // 0x3C '<'
    {0x14, 0x14, 0x14, 0x14, 0x14},  // 0x3D '='
    {0x00, 0x41, 0x22, 0x14, 0x08},  // 0x3E '>'
    {0x02, 0x01, 0x51, 0x09, 0x06},  // 0x3F '?'
    {0x32, 0x49, 0x79, 0x41, 0x3E},  // 0x40 '@'
    {0x7E, 0x11, 0x11, 0x11, 0x7E},  // 0x41 'A'
    {0x7F, 0x49, 0x49, 0x49, 0x36},  // 0x42 'B'
    {0x3E, 0x41, 0x41, 0x41, 0x22},  // 0x43 'C'
    {0x7F, 0x41, 0x41, 0x22, 0x1C},  // 0x44 'D'
    {0x7F, 0x49, 0x49, 0x49, 0x41},  // 0x45 'E'
    {0x7F, 0x09, 0x09, 0x09, 0x01},  // 0x46 'F'
    {0x3E, 0x41, 0x49, 0x49, 0x7A},  // 0x47 'G'
    {0x7F, 0x08, 0x08, 0x08, 0x7F},  // 0x48 'H'
    {0x00, 0x41, 0x7F, 0x41, 0x00},  // 0x49 'I'
    {0x20, 0x40, 0x41, 0x3F, 0x01},  // 0x4A 'J'
    {0x7F, 0x08, 0x14, 0x22, 0x41},  // 0x4B 'K'
    {0x7F, 0x40, 0x40, 0x40, 0x40},  // 0x4C 'L'
    {0x7F, 0x02, 0x04, 0x02, 0x7F},  // 0x4D 'M'
    {0x7F, 0x04, 0x08, 0x10, 0x7F},  // 0x4E 'N'
    {0x3E, 0x41, 0x41, 0x41, 0x3E},  // 0x4F 'O'
    {0x7F, 0x09, 0x09, 0x09, 0x06},  // 0x50 'P'
    {0x3E, 0x41, 0x51, 0x21, 0x5E},  // 0x51 'Q'
    {0x7F, 0x09, 0x19, 0x29, 0x46},  // 0x52 'R'
    {0x46, 0x49, 0x49, 0x49, 0x31},  // 0x53 'S'
    {0x01, 0x01, 0x7F, 0x01, 0x01},  // 0x54 'T'
    {0x3F, 0x40, 0x40, 0x40, 0x3F},  // 0x55 'U'
    {0x1F, 0x20, 0x40, 0x20, 0x1F},  // 0x56 'V'
    {0x3F, 0x40, 0x38, 0x40, 0x3F},  // 0x57 'W'
    {0x63, 0x14, 0x08, 0x14, 0x63},  // 0x58 'X'
    {0x07, 0x08, 0x70, 0x08, 0x07},  // 0x59 'Y'
    {0x61, 0x51, 0x49, 0x45, 0x43},  // 0x5A 'Z'
    {0x00, 0x7F, 0x41, 0x41, 0x00},  // 0x5B '['
    {0x02, 0x04, 0x08, 0x10, 0x20},  // 0x5C '\'
    {0x00, 0x41, 0x41, 0x7F, 0x00},  // 0x5D ']'
    {0x04, 0x02, 0x01, 0x02, 0x04},  // 0x5E '^'
    {0x80, 0x80, 0x80, 0x80, 0x80},  // 0x5F '_'
    {0x00, 0x03, 0x05, 0x00, 0x00},  // 0x60 '`'
    {0x20, 0x54, 0x54, 0x54, 0x78},  // 0x61 'a'
    {0x7F, 0x48, 0x44, 0x44, 0x38},  // 0x62 'b'
    {0x38, 0x44, 0x44, 0x44, 0x20},  // 0x63 'c'
    {0x38, 0x44, 0x44, 0x48, 0x7F},  // 0x64 'd'
    {0x38, 0x54, 0x54, 0x54, 0x18},  // 0x65 'e'
    {0x08, 0x7E, 0x09, 0x01, 0x02},  // 0x66 'f'
    {0x0C, 0x52, 0x52, 0x52, 0x3E},  // 0x67 'g'
    {0x7F, 0x08, 0x04, 0x04, 0x78},  // 0x68 'h'
    {0x00, 0x44, 0x7D, 0x40, 0x00},  // 0x69 'i'
    {0x20, 0x40, 0x44, 0x3D, 0x00},  // 0x6A 'j'
    {0x7F, 0x10, 0x28, 0x44, 0x00},  // 0x6B 'k'
    {0x00, 0x41, 0x7F, 0x40, 0x00},  // 0x6C 'l'
    {0x7C, 0x04, 0x18, 0x04, 0x78},  // 0x6D 'm'
    {0x7C, 0x08, 0x04, 0x04, 0x78},  // 0x6E 'n'
    {0x38, 0x44, 0x44, 0x44, 0x38},  // 0x6F 'o'
    {0x7C, 0x14, 0x14, 0x14, 0x08},  // 0x70 'p'
    {0x08, 0x14, 0x14, 0x18, 0x7C},  // 0x71 'q'
    {0x7C, 0x08, 0x04, 0x04, 0x08},  // 0x72 'r'
    {0x48, 0x54, 0x54, 0x54, 0x20},  // 0x73 's'
    {0x04, 0x3F, 0x44, 0x40, 0x20},  // 0x74 't'
    {0x3C, 0x40, 0x40, 0x20, 0x7C},  // 0x75 'u'
    {0x1C, 0x20, 0x40, 0x20, 0x1C},  // 0x76 'v'
    {0x3C, 0x40, 0x30, 0x40, 0x3C},  // 0x77 'w'
    {0x44, 0x28, 0x10, 0x28, 0x44},  // 0x78 'x'
    {0x0C, 0x50, 0x50, 0x50, 0x3C},  // 0x79 'y'
    {0x44, 0x64, 0x54, 0x4C, 0x44},  // 0x7A 'z'
    {0x00, 0x08, 0x36, 0x41, 0x00},  // 0x7B '{'
    {0x00, 0x00, 0x7F, 0x00, 0x00},  // 0x7C '|'
    {0x00, 0x41, 0x36, 0x08, 0x00},  // 0x7D '}'
    {0x08, 0x08, 0x2A, 0x1C, 0x08}   // 0x7E '~'
};

void ssd1306_send_command(uint8_t command) {
    uint8_t buffer[2] = {0x00, command};
    HAL_I2C_Master_Transmit(&I2C_DEVICE, OLED_ADDRESS, buffer, 2,
                            HAL_MAX_DELAY);
}

void ssd1306_send_data(uint8_t* data, size_t size) {
    uint8_t* buffer = (uint8_t*) malloc(
        size + 1);  // TODO: replace with static buffer or portalloc?
    buffer[0] = 0x40;
    memcpy(&buffer[1], data, size);
    HAL_I2C_Master_Transmit(&I2C_DEVICE, OLED_ADDRESS, buffer, size + 1,
                            HAL_MAX_DELAY);
    free(buffer);
}

void ssd1306_init() {
    ssd1306_send_command(0xAE);  // Display OFF

    ssd1306_send_command(
        0xD5);  // Set display clock divide ratio/oscillator freq
    ssd1306_send_command(0x80);  // Default setting

    ssd1306_send_command(0xA8);  // Set multiplex ratio
    ssd1306_send_command(0x3F);  // 1/64 duty

    ssd1306_send_command(0xD3);  // Set display offset
    ssd1306_send_command(0x00);  // No offset

    ssd1306_send_command(0x40);  // Set start line to 0

    ssd1306_send_command(0x8D);  // Enable charge pump
    ssd1306_send_command(0x14);  // Enable

    ssd1306_send_command(0x20);  // Set Memory Addressing Mode
    ssd1306_send_command(0x00);  // Horizontal addressing mode

    ssd1306_send_command(0xA1);  // Segment re-map
    ssd1306_send_command(0xC8);  // COM Output Scan Direction

    ssd1306_send_command(0xDA);  // COM pins hardware config
    ssd1306_send_command(0x12);

    ssd1306_send_command(0x81);  // Set contrast control
    ssd1306_send_command(0xCF);

    ssd1306_send_command(0xD9);  // Set pre-charge period
    ssd1306_send_command(0xF1);

    ssd1306_send_command(0xDB);  // Set VCOMH deselect level
    ssd1306_send_command(0x40);

    ssd1306_send_command(0xA4);  // Resume to RAM content display
    ssd1306_send_command(0xA6);  // Normal display

    ssd1306_send_command(0xAF);  // Display ON
}

void ssd1306_clear(void) {
    uint8_t zeroBuffer[128] = {0};

    for (uint8_t page = 0; page < 8; page++) {
        ssd1306_send_command(0xB0 + page);  // Set page address
        ssd1306_send_command(0x00);         // Set column low nibble
        ssd1306_send_command(0x10);         // Set column high nibble
        ssd1306_send_data(zeroBuffer, 128);
    }
}

void ssd1306_write_char_to_buffer(Display_t* display, char c,
                                  uint8_t cursor_row, uint8_t cursor_col) {
    // TODO: Add checks to make sure cursor_row and cursor_col are non-negative and
    // less than the maximum respective value.
    if (c < 0x20 || c > 0x7E)
        c = '?';
    const uint8_t* glyph = font5x7[c - 0x20];

    // Write glyph to displayBuffer
    for (int i = 0; i < 5; i++) {
        display->buffer[cursor_row][cursor_col++] = glyph[i];
    }
    display->buffer[cursor_row][cursor_col++] = 0x00;  // spacing
}

int get_line_start_index(const char* msg, uint8_t line) {
    uint8_t cursor_row = 0;
    uint8_t cursor_col = 0;
    uint8_t good = 0;
    size_t i;
    for (i = 0; i < strlen(msg); i++) {
        if (cursor_row == line) {
            good = 1;
            break;
        }

        if (msg[i] == '\n') {
            cursor_row++;
            cursor_col = 0;
        } else {
            cursor_col += CHAR_WIDTH;
            if (cursor_col >= OLED_WIDTH - CHAR_WIDTH) {
                cursor_row++;
                cursor_col = 0;
            }
        }
    }

    if (good == 1) {
        return i;
    } else {
        return -1;
    }
}

uint8_t get_line_count(const char* msg) {
    uint8_t cursor_row = 0;
    uint8_t cursor_col = 0;
    uint8_t count = 0;
    int msg_length = strlen(msg);
    for (int i = 0; i < msg_length; i++) {
        if (msg[i] == '\n') {
            cursor_row++;
            cursor_col = 0;
            count++;
        } else {
            cursor_col += CHAR_WIDTH;
            if (cursor_col >= OLED_WIDTH - CHAR_WIDTH) {
                cursor_row++;
                cursor_col = 0;
                count++;
            }
        }
    }

    if (msg[msg_length - 1] != '\n')
        count++;
    return count;
}

void ssd1306_write_title(Display_t* display, Message_t message,
                         uint8_t offset) {
    memset(display->buffer[0], 0, OLED_WIDTH);
    uint8_t title_length = strlen(message.title);
    uint8_t cursor_col = 0;
    for (int i = offset; i < title_length && i < offset + MAX_COLS; i++) {
        char c = message.title[i] == '\n' ? ' ' : message.title[i];
        ssd1306_write_char_to_buffer(display, c, 0, cursor_col);
        cursor_col += CHAR_WIDTH;
    }
}

void ssd1306_write_body(Display_t* display, Message_t message,
                        uint8_t line_start) {
    // Zero body rows.
    for (int i = 1; i < MAX_ROWS; i++) {
        memset(display->buffer[i], 0, OLED_WIDTH);
    }

    uint8_t cursor_row = 1;
    uint8_t cursor_col = 0;
    int body_length = strlen(message.body);
    int i = get_line_start_index(message.body, line_start);
    while (cursor_row < MAX_ROWS && i < body_length && i >= 0) {
        if (message.body[i] == '\n') {
            cursor_row++;
            cursor_col = 0;
        } else {
            ssd1306_write_char_to_buffer(display, message.body[i], cursor_row,
                                         cursor_col);
            cursor_col += CHAR_WIDTH;
            if (cursor_col >= OLED_WIDTH - CHAR_WIDTH) {
                cursor_row++;
                cursor_col = 0;
            }
        }
        i++;
    }
}

void ssd1306_write_buffer_to_gddram(Display_t* display) {
    for (uint8_t page = 0; page < MAX_ROWS; page++) {
        ssd1306_send_command(0xB0 + page);  // page addr
        ssd1306_send_command(0x00);         // lower column
        ssd1306_send_command(0x10);         // higher column
        ssd1306_send_data(display->buffer[page], OLED_WIDTH);
    }
}
